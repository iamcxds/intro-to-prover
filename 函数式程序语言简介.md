
# 导言

以 Haskell 等语言为代表的函数式编程(functional programming, 简称 FP )可能是人人都听说过的，但从数据上来看普及率还相对较低。函数式语言不仅是计算机辅助证明的基础，事实上在我看来这本来也是最适合有一定数学基础的人学习的程序语言。然而我其实没看到很 concise 引导文章，要不然过于详尽，要不然作者没有足够的数学基础。而 FP 方面的大佬往往更倾向于讨论更技术性的问题，所以入门级别的文章的确不多见。于是想写一篇作为[计算机辅助证明简介](https://zhuanlan.zhihu.com/p/181671237)的后续(或者前置)，一方面正好可以讲解一些在辅助证明中需要用到的概念和思想，另一方面也是对 FP 的安利吧。也可以也看作是学习笔记吧，有错误的地方也欢迎指正。

事实上我自己也算是FP入门新手，不可能讲太深刻的东西，不过正是这样我恰恰还能体会一些入门时的困难点。本文将不限于某种特定的语言，更关注FP背后的思想，所以有时候为了方便理解可能会写一些格式不太准确的代码。我依旧把我介绍的内容归为数学，正如 Haskell 的创始人之一 Philip Wadler 在[一次演讲](https://www.bilibili.com/video/bv1nk4y1273w)的最后讲到的一样
>我认为**信息学**(informatics)是一个更好的词(来描述这些知识)，计算机科学(computer science)只有计算机和科学。因为这些知识并不是只与计算机有关，它是关于**信息的模式**(patterns of information)的。另外如果你是真正的科学的话，你不用把科学加到你的名字里。

![wadler](./image/Philip-Wadler.png "Philip Wadler 每次演讲结尾的传统艺能")

# 为什么FP很重要

相信类似的说法大家已经看过很多了，其中最为经典的便是Haskell的另一创始人 John Hughes ( Haskell 的创始人真的有点多)的同名[论文](https://www.cs.kent.ac.uk/people/staff/dat/miranda/whyfp90.pdf)和[演讲](https://www.bilibili.com/video/BV14W411b7cr)。

在没有介绍详细内容前，我能谈到的一些基于我个人经历的感受。

- 理解之后，上手很快
  - 我真正开始学习FP到现在也就大半年，我在2020年元旦开始学习 elm ，不到一个月后(中途还夹杂着期末考试)我就用它做了一个[黎曼面上游戏demo](https://github.com/iamcxds/Monodromy)(当然这也和 elm 本身易上手有关)。里面用到的很多方法都是命令式编程实现起来很麻烦的

- 轻松写出 bug-free 的代码
  - 我依旧记得用 C# 做游戏遇到莫名其妙的 bug 气得锤桌子。但是利用基于类型系统的静态类型检查，FP 可以在代码还未编译前就发现错误，并且根据有类型信息的报错信息这些错误往往很容易改正。因为是没有副作用(side effect)的纯函数代码，除此之外的 bug 就很少了，elm 甚至声称它不会有 runtime 错误。
  
- 基于类型的代码好写更好读
  - 类型系统除了能提供静态检查功能外，还能提供大量的信息(在计算机辅助证明中甚至能代表数学命题)。通过类型系统，我们可以构建更好的程序模型(如接下来会介绍的elm架构)，更有助于我们拆分模块化程序。而程序函数的类型同时也能起到指示函数的作用的功能，这也极大的帮助了我这样不习惯写注释的人看懂自己的代码。

# 年轻人的第一个FP程序
  
对于第一次学习 FP 的人，我一定会推荐 [elm](https://elm-lang.org/) 这个语言，不仅因为它简单(虽然功能有限)，而且是直接编译成网页的 JavaScript 脚本。这两点意味着它可以极快速地构建出可视的小玩意(而不只是命令行里的一句`Hello world`)，甚至不需要用户安装任何东西，直接在浏览器里捣鼓[在线编辑器](https://elm-lang.org/try)就可以了。
当然如果未来真的希望使用FP进行JS相关的开发，我还是更推荐功能更全面的 [Purescript](https://www.purescript.org/)，不过Purescript不太适合初学者上手，所以也可以先学习 elm 作为跳板。

我们便使用 elm 作为我们目前例子的语言，因为各种 FP 里的语法结构大同小异，切换起来也很方便。

在开始正式介绍之前，我们先明确一下**函数**(function)和**类型**(type)的概念。函数最粗浅地理解是就是类型(集合)之间的映射，除此之外不做任何事情。数学上对函数的认识是考虑它具体**是什么**，并认为它是“瞬间”完成的，而不是考虑**一步一步**去达成目标。这也是FP和命令式编程在思想上的核心区别。所以 FP 中是没有计算机中传统的“变量”这个概念的，所有记号对应的都是常量，当然对于函数还是可以谈论其变量的。
用$A \rightarrow B$记类型A到类型B的函数的类型。最简单的例子

```elm
plusOne : Int -> Int
plusOne n = n + 1 --用这种方式定义函数，把自变量直接写在函数后
```

而因为函数本身也构成类型，所以函数类型也可以作为定义域和值域(甚至有些情况下函数类型与非函数类型没有明确的界限)

```elm
five : (Int -> Int) -> Int --函数类型作为定义域
five f = f 5 --即 f(5)，而这种写法可以省去不少括号。
--以函数为自变量固定取其在5的值作为结果的函数。

plus : Int -> (Int -> Int)--函数类型作为值域，我们默认 ->是右结合的，所以这种时候的括号可以省略
plus x =
  let --使用let in可以定义一些局部使用的记号
    xPlus : Int -> Int --这里的类型声明可以省略
    xPlus y = x + y --根据x得到的加上x函数
  in
    xPlus --以xPlus为结果

--不过这样下去类型会写得越来越长，我们可以给类型命名，可以用type alias 给类型定义一个记号
type alias IIi = Int -> Int -> Int
--另外你会嫌定义函数太麻烦，其实我们有更简便的写法
plus1 : IIi
plus1 x = \y -> x+y -- 用\符号可以定义一个匿名函数，\y表明自变量，箭头 -> 后写上函数的结果，后面我们可以看到这是一种λ表达式。

--当我们运行函数时
> (plus 3) 5 -- 先计算plus 3的结果，得到加3的函数，再对5应用
8
> plus1 5 3 --函数的应用默认是右结合的，所以可以不用加括号
8
```

我们很惊讶的发现，当我们用函数作为值域的时候似乎定义出了二元函数。事实上这并不奇怪，在集合范畴我们很容易得到同构$\rm{Hom}(A,\rm{Hom}(B,C))\cong\rm{Hom}(A\times B,C)$( Hom 在这里就表示两个集合间的映射集合)。如果继续这种操作，我们甚至可以定义任意多元函数类型。这种将多元函数定义为值域为函数的函数的操作，被称为 curry 化。这样操作带来的好处是：从内核上来讲FP里面只有一元函数，各种系统和理论处理起来更容易(认识到这件事能对读懂报错信息很有帮助)；但是使用时可以没有通常区别得一样定义，使用任意多元函数。

```elm
plus2 : IIi
plus2 x y = x + y --可以直接像多元函数一样定义

plus3 : IIi
plus3 = \x y -> x + y --也可以直接用匿名表达式定义“多元”函数
```

## Elm架构(The Elm Architecture)

所有第一次听说 FP 的人都会有这样的疑问：如果真的是没有副作用的纯函数程序话，如何实现人机交互？不然除了能做计算程序还可以干什么？

专家也许马上会开始解释什么是 monad ，但是与其让初学者陷入这些概念的泥潭，我们不如先把这个东西当成黑盒(black box)，我们先来看看有了某个黑盒之后纯函数是怎么通过其实现交互程序的。

Elm架构就是一个很好的黑盒，事实上它本身也是诸如网页应用，游戏等交互程序很好的范式。虽然我总觉得这么好的东西可能不是elm原创的，这个架构也有一些 FRP (functional reactive programming)的影子，不过似乎网上都这样叫我们就沿用吧。我们主要参考的是elm的[官方指导](https://guide.elm-lang.org/)，这个官方写得挺好挺concise，之后大家可以自行继续学习。

一个交互程序可以分解为三个部分：

- 模型(Model)——某个数据类型用于存储当前状态,另外我们还应该定义一个初始数据对应于程序刚开始的状态
- 显示(View)——将当前状态数据渲染成前端显示元素的函数，在这里是渲染成Html代码
- 更新(Update)——根据前端传来的消息(message，简写 msg)对状态数据进行更新的函数

![elm](image/buttons.svg "Elm架构示意图，左边代表elm程序，右边代表显示前端(电脑，浏览器)")

根据描述，我们大概可以想象这些部分所需要函数和类型。

```elm
--首先是模型部分
type alias Model = ... --定义状态数据类型，事实上可以理解为全体“全局变量”
init : Model
init = ... --定义初始数据

--接下来是更新部分

type alias Msg = .. --定义消息类型

update : Msg -> Model -> Model --有两种角度来看待这个函数：当做是消息和当前状态的二元函数，以此决定下一个函数；当做是消息的一元函数，结果是对状态如何更新的函数
update msg model = ...

--最后是显示类型

view : Model -> Html Msg -- 这里类型写成这样的具体含义不用管，因为网页即是显示部件又是交互部件，这样的含义是把状态渲染成Html网页，而且网页可以回传Msg类型的消息。事实上这里的Html是一个函子。
view model = ...
```

所以，对于一个最简单的例子，做一个可以加减数的按钮，代码就是[这样](https://elm-lang.org/examples/buttons),大家可以点击代开在线编辑器体验。

```elm
-- MAIN
main =
  Browser.sandbox { init = init, update = update, view = view }--Browser.sandbox就是黑盒的本体，只需要按规定定义好类型和函数，输入进去就可以实现想要的程序。另外由于FP不是逐条运行命令的，所以这些定义在前在后都不影响。
--sandbox另一个神奇的地方在于，不像我们之前定义的函数，定义域类型是固定的，而是满足一定相关条件的类型都可以接受。这实际上是一种多态(polymorphism),这种功能需要更复杂的类型系统才能实现，比如后文会提到的type class。
-- MODEL
type alias Model = Int
init : Model
init =
  0
-- UPDATE
type Msg  --Msg所对应的类型的含义我们将在后文讲解
  = Increment
  | Decrement

update : Msg -> Model -> Model
update msg model =
  case msg of  --这里使用了模式匹配(pattern matching),将在后文讲解
    Increment ->
      model + 1
--如果有经验的话会发现这其实是命令式编程写法最令人迷惑的赋值语句 n = n + 1; 真正数学上的表达
    Decrement ->
      model - 1

-- VIEW
view : Model -> Html Msg
view model =
  div []
    [ button [ onClick Decrement ] [ text "-" ]
    , div [] [ text (String.fromInt model) ]
    , button [ onClick Increment ] [ text "+" ]
    ]-- elm 语言中以函数的写法写得html，注意到 onClick触发的是Msg类型的消息
```

我们可以设想一下如果我们要做一个todoList的应用还需要哪些功能和函数？

至少从上面的例子可以看出，FP 里不是完完全全没有副作用，但是 FP 里会把有副作用的部分集中起来成为黑盒，这样可以让副作用的部分更精简更可控；而真正实现功能的部分是纯函数的，可以利用类型系统带来的好处，也可以避免副作用产生的意想不到的效果。

## 并类型(union type)与模式匹配(pattern matching)

我们在之前的讨论中，还有一些尚未解决的问题。首先我们的消息，可能有很多种不同的情况：有的消息传来数字，有的消息传来字符，有的消息只是单纯的消息。但是我们只能定义一个消息类型 `Msg` ，怎么办？然而事实上这些消息类型都是并列关系，那我们只用把它们并起来不就好了吗。回忆起集合的无交并(disjoint union)或者 coproduct，就是把两个两个集合放在一起罢了。
![coprod](image/560px-Coproduct-03.svg.png "无交并的泛性质")

我们根据此定义并类型(union type， 在 elm 中被叫做 custom type ，也有其他地方叫 algebraic data type的)，当然与之对应的乘积类型(笛卡尔积)也是存在。

```elm
--用 type 定义并类型
type SomeUnion -- 把类型A，B等等并起来的类型，由于elm没有函子，我们只能定义这样固定的类型
  = Incl1 A -- Incl1是加在类型前的自定义记号
  | Incl2 B -- 用"|"来表示并列
  | Incl3 C -- 还可以继续这样并上更多的类型
  | Other D E --甚至可以连跟两个类型，这样类似并上了 D×E

Incl1 : A -> UnionAB -- Incl1 既是这样一个函数，又是一个记号
Incl1 a : UnionAB -- a:A，SomeUnion的项都可以写成类似这样的形式

--当然乘积类型也是有的
--二元乘积类型
(a,b) : ( A , B )--elm里用这种括号来代表二元乘积类型 A×B

--多元乘积类型可以用这样的叫做 record 的东西来定义
type alias ColorPoint3D = -- Int × Int × Int × Color
  { x : Int
  , y : Int
  , z : Int
  , color : Color
  }

.x : ColorPoint3D -> Int -- 用这样的方式来表示对分量的投影，当然更方便写法是 a.x : Int 这样的形式，其中 a : ColorPoint3D
```

我们注意到在定义中我们会在每个要并列的类型前加上一个符号(`Incl1`)，这个符号既代表无交并中的 canonical inclusions (如上面交换图中的$i_1, i_2$)，另一方面这也是并类型的项构造器。

但是如果我们只是想传递单纯的消息，我们要用到一种特殊的 unit type(在 C 系列语言里面一般是称为 void(空)，但是这是非常有误导性，事实上空集对应是 initial object)，它对应的是集合中的单点集$*\in\rm{pt}$。它是范畴中终对象(terminal object，意味着其他集合到它有唯一的映射)。

```elm
unit : Unit -- elm中用()表示 unit type 又表示它唯一的项，因为elm的类型和项界限分明所以可以这样表示，我们这里为了叙述清晰用 unit 和 Unit 区分

--定义一些与unit相关的函数
constA : A -> Unit  -- A 到 unit 的唯一函数
constA a = unit

isoA : A -> Unit -> A
isoA a _ = a -- 当某个变量不影响结果时，比如这里Unit的项，我们可以在定义中用_来代替它。
-- 值得注意的是通过isoA这个函数，类型A同构于函数类型 Unit -> A。再结合 curry 化，我们可以说所有类型都是(一元)函数类型。这也是为什么 FP 中函数作为 first class


type Msg  --之前使用的 Msg
  = Increment -- 可以是当做 Increment Unit 的简写，于是这里Increment只是传递了一个单纯的消息
  | Decrement
  --这实际上是定义了一个二元集合

Increment : Msg -- 类似之前的 Incl1，Increment 的类型其实是 Unit -> Msg, 但因为上述同构我们可以直接处理为Msg
```

随之而来的问题，我们如何定义并类型的函数。事实上再次查看泛性质的交换图我们可以知道$\rm{Hom}(A\sqcup B,C)=\rm{Hom}(A,C)\times \rm{Hom}(B,C)$，所以我们实际上是需要对每个部分都定义函数了。所以为了能实现这件事，我们需要模式匹配，某种意义上是 `if` 或者 `switch` 结构的升级版，而且不仅仅是匹配值，匹配的是模式。

```elm
fun : SomeUnion -> R --定义一个到R的函数
fun u =
  case u of --case就是模式匹配的语法，对于u分情况讨论
    Incl1 a -> ... --当项来自于A时的情况
    Incl2 b -> ...
    Incl3 _ -> ... -- 如此依旧会匹配 Incl3 c这样的值，但结果与c无关
    _ -> ... --这个会匹配所有剩余情况
    --elm不允许partial function，意味着使用case后必须要讨论完所有可能性

--当然模式匹配不只可以匹配并类型，函数中任何变量都可以匹配
isLong : String -> Bool
isLong word =
  case length word of --length : String -> Int 给出字符串的长度
    0 -> False
    1 -> False
    _ -> True --其他情况都是true

```

当然模式匹配在其他 FP 语言还可以有其他的语法形式，比如说 Haskell 里的 guard 。

```haskell
sayMe :: Int -> String  
sayMe 1 = "One!"  
sayMe 2 = "Two!"  
sayMe _ = "Too big!"  
```

并类型的另一个作用是可以处理未定义行为。未定义行为是程序错误的来源，而 FP 的一大优势是可以通过类型来帮助处理未定义行为。比如说为了定义一个获取 List 第 n 个元素的函数，为了防止超出 List 最大 index，我们有两种办法:

- 通过 dependent type 定义获取函数取值必须被控制在某个范围，这是最佳的解决方案，但需要更复杂的类型系统。

```idris
get : (li : List A) -> Finset (length li) -> A
||| 将第二个变量限制在比 length 更小的有限集合中
```

- 我们将错误也作为一种结果，与正常结果并列。
  
```elm

type Maybe A --这是 elm 少有的自带的函子
  = Just A
  | Nothing --事实上就是把A外加上额外一个点，用作异常处理

--下面两个函数的定义我们要到介绍了LIst的定义后才能给出
get : List A -> Int -> Maybe A --任何超出范围的获取都会得到Nothing
head : List A -> Maybe A --获取首个元素

headString : List String -> String
headString liStr =
  case head liStr of
    Just str -> str
    Nothing -> "There is nothing"
```

可以看出利用这样的方式可以引导(迫使)用户进行异常处理，也不用画蛇添足一般用 `try... catch`，虽然有时不得不分类讨论略显繁琐，但却是 bug-free 的保障。另外`Maybe`其实也是一种 monad ，如果在可以使用 monad 的 do 结构的语言，这种异常处理可以更简洁一点。

## 递归(recursive)与归纳类型(inductive type)

可以看到我们至今没有定义循环结构，事实上在 FP 中递归是比循环更自然的,因为我们定义一个函数不是通过遍历整个类型(这是一种偏集合的想法)，而是通过模式匹配或者归纳法定义。

```elm
factorial : Nat -> Nat --假设我们有自然数的类型
factorial n =
  if n == 0 then 1
  else factorial (n-1) --教科书式的递归

--我们也可以通过递归定义循环
while : (A -> Bool) -> A -> (A -> A) -> A
while pred init f = --三个参数分别为判断是否跳出，初始值和每次运行的作用函数
  if pred init then while pred (f init) f --如果满足条件则对 f init 继续进行判断
  else init --如果不满足条件直接跳出
  --最后结果是某个不满足条件的 f(..(f( init ))..)
```

递归不仅可以出现在函数中，更可以出现在类型中，此时便是得到的归纳类型，而此时的模式匹配便更有了归纳的意味。我们尝试以此来定义一些基本的结构(造轮子)。

```elm
--我们先来看看最简单的例子自然数
type MyNat
  = Z -- 0，0是自然数
  | S MyNat -- S 代表+1 ，这里的含义可以理解为，n为自然数的话 n+1也是
--自己的定义中引用了自己便可以算作归纳类型，Z 和 S 像是生成元，于是MyNat的项便类似于 S(..(S(S Z)))有几个S就对应于几

plusNat : MyNat -> MyNat -> MyNat
plusNat x y = --x+y
  case y of
    Z-> x -- x+0=x
    S z -> plusNat (S x) z -- x + (z+1) = (x+1) + z
--可以从两个角度去理解这个函数，首先是归纳法，对于y的值归纳得定义加法；
--齐次可以分析这个变化的过程，对于S(..(S(S Z))) + S(..(S(S Z)))，我们不断把右边的S挪到左边，直到最后变成S(..(S(S Z)))+ Z 的形式给出结果。这本是一个复杂的过程，但利用归纳类型可以简介的定义
--但如果要证明自然数相关的定理elm就做不到了，还是必须要dependent type
--proof : ( n: Nat ) -> P n 我们回忆之前文章中提到的dependent function，为了给出这个函数(证明)，我们会用到更接近真正意义上的归纳法

type MyListA
  = Nil --代表空 List
  | Con A MyListA -- 给已有的list前面加上一个元素
--此时Nil,Con a 作为生成元的感觉, ListA的项的事实上都是Con a_n (.. Con a_1 (Con a_0 Nil) ..)，但我们使用模式匹配时不需要考虑到这种具体形式

head : MyListA -> Maybe A
head li =
  case li of
    Nil -> Nothing
    Con a _ -> Just a

--考虑一个更复杂的函数，给定一个函数，我们希望用其遍历整个List
map : (A -> A) -> MyListA -> MyListA
map f li =
  case li of
    Nil -> Nil
    Con a xs -> Con (f a) (map f xs)
--类比归纳法，我们先对长度为0的list定义函数，然后再利用长度为n时的函数定义长度为n+1是时的函数

--结合这上面的，我们可以来定义一个get函数
get : MyListA -> MyNat -> Maybe A
get li n =
  case li of
    Nil -> Nothing
    Con x xs ->
      case n of
        Z -> Just x
        S m -> get xs m

--类似地我们可以定义二叉树,读者也可以试着自行定义类似的函数
type TreeA
  = Leaf A
  | Node A TreeA TreeA
```

了解了这些内容，基本上可以算是 FP 入门了。凭借这些知识外加一些 elm 一些语法知识(比如如何使用或更新 record)，还有与网页交互的 api 应该可以做出一些[简单的游戏](https://github.com/rofrol/elm-games)了(我一直认为做游戏是学习编程最好的方式)。我个人很推荐的一个[像素游戏引擎](https://github.com/Orasund/pixelengine)(我自己也是用它做的游戏)，并且还有很详尽的[教程展示](https://orasund.github.io/pixelengine/)。

# type class，函子(functor) 与 monad

接下来我们会更深入一些与 FP 相关的理论，elm 也没有提供足够的概念，我们将使用 Haskell 来进行讲解。注意到 Haskell 和 elm 有一些的区别。

```haskell
name :: String --类型项用的是 ::
name = "name"

type IntFun = Int -> Int -- 给类型起名使用 type 而非 type alias

type ListInt = [Int] -- 用[..]来代表 List类型

data Union a b -- 并类型使用 data 而非 type
  = Incl1 a --注意到这里我们使用的是小写 a 来代表类型，这实际上是类型变量(type variable)，我们接下来会解释
  | Incl2 b
```

我们使用 Haskell 的一个重要原因是可以使用类型变量(type variable)。事实上由于全体的(通常)类型组成一个更高阶的类型 `Type`，我们其实可以定义 `Type` 相关的高阶函数类型，比如说 `Type -> Type`，而在定义过程中我们会用到的变量记号，如 `a : Type, f : Type -> Type`。而数学中比较常见的函子(functor)，事实上是一种更特殊的高阶函数 `functor : Type -> Type`

```haskell
data Maybe :: Type -> Type -- 给Maybe输入一个type，输出一个type
data Maybe a -- 就像是定义函数一样
  = Just a | Nothing

data Union :: Type -> Type -> Type --给Union输入两个type输出一个type
```

类型变量意味着类型本身可以表现得像项一样(集合也可以作为集合的元素)，但 Haskell 也并不是完全实现了依赖类型的，所以还是会有所限制。由于类型之间有态射(函数)形成了一个范畴结构，所以函子`functor: Type -> Type` 间也是有范畴结构的(注意我们要有了 type class 后才能确切定义函子)

- (list monad,IO monad,state monad 实现elm架构)
- type class 数学的抽象，冒泡排序

# lambda 演算(lambda calculus)

# 结语

- 一种理念上的编程，缺乏对效率的考虑
  